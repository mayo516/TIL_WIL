# 완전탐색 DFS, BFS , 백트랙킹

## 그래프 (Graph)

- 그래프 실생활 예 : 지도 , 내비게이션


E - 간선 

V - 정점 

- 무방향 그래프 (= 양방향 그래프)
- 방향 그래프

- 순환그래프
- 비순환그래프

- 연결요소  :연결요소가 1개가 아닌 그래프도 있다.

## 트리 (Tree)

순환성이 없는 무방향 그래프(수학적인 개념) 

- 특정하지 않는 한 어떤 노드든지 루트( root)가 될 수 있다
- 가장 바깥쪽 노드는 리프노드(leaf node)
- node A에서 nodeB로 가는 경로는 반드시 존재하며 유일하다
- 노드개수 = 간선개수 + 1
- **자료구조에서의 트리는 부모 → 자식 관계가 있는 방향 그래프이다.**
- 루트(root)는 하나다


## 코드로 그래프를 나타내는 방법

1. 인접 행렬 
2. 인접리스트
    - 파이썬에서는 리스트로 많이 구현한다.

### 인접행렬 vs 인접리스트

- 비교
    - 시간 과 공간의 트레이드오프
- 인접행렬은 공간을 많이 차지하지만 빠르게 연결되어있는지 찾을 수 있다. (시간적으로 유리)
- 인접 리스트는 이것과 반대
- 간선이 적을수록 인접 리스트가 우세 , 간선이 많으면 인접 행렬이 우세


## DFS (Depth First Search)

- 스택 or 재귀를 사용해서 구현한다
- 완전 탐색이라 모든 노드를 다 살펴본다 .

## BFS (Breadth First Search)

- 큐를 사용해서 구현한다.
- 완전 탐색이라 모든 노트를 다 살펴본다.

![image 5](https://github.com/user-attachments/assets/7c14e480-5a67-4a96-81ab-7a2d92ea951c)


### DFS & BFS

- 공통점
    - 완전탐색의 특징을 갖는다 : 반드시 답을 찾는다, 모든걸 확인하니깐 느릴 수 있다.
- 차이점
    - 뭔가를 찾는 문제거나, 최단 거리를 묻는 문제가 나온다.
    - BFS가 최단 거리 탐색에서 유리하다.

## 시간복잡도

- 인접행렬 VS 인접 리스트
    - 인접 행렬O( V( 정점)^2)
    - 인접 리스트 O(V(정점)+E)

## 길찾기 문제

- 보통 4방향이 많다
- 방향값을 미리 코드에 짜두고 for문으로 순회하는 기법을 꼭 익혀두자.
- 방문체크 필요
- 각 칸이 노드
- 상하좌우 4방향의 간선

```python
from collections import deque
dy = ( 0 , 1 , 0 , -1)
dx = (1 , 0 , -1 , 0)
chk = [[False]* 100 for _ in range(100)]
N = int(input())

def is_valid_coord(y, x):
    return 0 <= y < N and 0 <= x < N

def bfs(strat_y, start_x):
    q = deque()
    q.append((strat_y, start_x))
    while len(q) > 0 :
        y , x = q.popleft()
        chk[y][x] = True
        for k in range(4):
            ny = y + dy[k]
            nx = x + dx[k]
            if is_valid_coord(ny, nx) and not chk[ny][nx]:
                q.append((ny, nx))
```

<aside>
💡

### 1. **프로그래밍 좌표계 (배열)**

- **y축(행)**: 위에서 아래로 갈수록 숫자가 커짐. 예를 들어, `(0, 0)`이 배열의 왼쪽 상단에 있고, `y` 값이 커질수록 아래로 이동하게 됩니다.
    - 즉, **아래쪽**으로 갈수록 y값이 **증가**.
    - **위쪽**으로 갈수록 y값이 **감소**.
- **x축(열)**: 왼쪽에서 오른쪽으로 갈수록 숫자가 커집니다. 즉, **오른쪽**으로 갈수록 x값이 **증가**하고, **왼쪽**으로 갈수록 x값이 **감소**합니다.

### 2. 수학적 좌표계와의 차이점

수학 좌표계에서는 **y축**이 위로 갈수록 커지지만, 프로그래밍에서의 2D 배열은 **위에서 아래로** y값이 커지는 방식입니다. 이것은 화면이나 그래픽 좌표계에서도 마찬가지입니다.

### 3. `dy`와 `dx`의 역할

다시 돌아와서 `dy`와 `dx`를 보면, 프로그래밍에서의 좌표계에 맞게 다음과 같이 동작합니다:

1. **오른쪽으로 이동**: `(dy, dx) = (0, 1)`
    - y축은 변화가 없고, x축(열)이 1 증가 → **오른쪽으로 이동**
2. **아래쪽으로 이동**: `(dy, dx) = (1, 0)`
    - y축(행)이 1 증가하고, x축은 변화가 없음 → **아래로 이동**
3. **왼쪽으로 이동**: `(dy, dx) = (0, -1)`
    - y축은 변화가 없고, x축이 1 감소 → **왼쪽으로 이동**
4. **위쪽으로 이동**: `(dy, dx) = (-1, 0)`
    - y축이 1 감소하고, x축은 변화가 없음 → **위로 이동**

---

따라서, **프로그래밍 좌표계에서는 y축이 아래로 갈수록 값이 커지고**, `dy`가 1이면 아래쪽으로, -1이면 위쪽으로 이동합니다.

</aside>

## 백트랙킹

- 두근두근 문예부..?
- 기본적으로 **모든 경우를 탐색**하며  DFS/BFS와 방식은 유사하다
- 백트랭킹은 **가지치기**를 통해 탐색 경우의 수를 줄인다는 차이가 있다.
    - 최악의 경우, 모든 경우를 다 살펴보게 될 수도 있지만 가능한 덜 보겠다는 전략
    - ‘가망성이 없으면 가지 않는다.’